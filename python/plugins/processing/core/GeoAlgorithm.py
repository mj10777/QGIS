# -*- coding: utf-8 -*-

"""
***************************************************************************
    GeoAlgorithm.py
    ---------------------
    Date                 : August 2012
    Copyright            : (C) 2012 by Victor Olaya
    Email                : volayaf at gmail dot com
***************************************************************************
*                                                                         *
*   This program is free software; you can redistribute it and/or modify  *
*   it under the terms of the GNU General Public License as published by  *
*   the Free Software Foundation; either version 2 of the License, or     *
*   (at your option) any later version.                                   *
*                                                                         *
***************************************************************************
"""

__author__ = 'Victor Olaya'
__date__ = 'August 2012'
__copyright__ = '(C) 2012, Victor Olaya'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'

from builtins import str
from builtins import object

import os.path
import traceback
import subprocess
import copy

from qgis.PyQt.QtCore import QCoreApplication

from qgis.core import (QgsProcessingFeedback,
                       QgsSettings,
                       QgsProcessingAlgorithm,
                       QgsProject,
                       QgsProcessingUtils,
                       QgsProcessingException,
                       QgsProcessingParameterDefinition,
                       QgsMessageLog)
from qgis.gui import QgsHelp

from processing.core.ProcessingConfig import ProcessingConfig
from processing.core.parameters import ParameterRaster, ParameterVector, ParameterMultipleInput, ParameterTable, Parameter
from processing.core.outputs import OutputVector, OutputRaster, OutputTable, OutputHTML, Output
from processing.algs.gdal.GdalUtils import GdalUtils
from processing.tools import dataobjects


class GeoAlgorithm(QgsProcessingAlgorithm):

    def __init__(self):
        super().__init__()

        # Outputs generated by the algorithm
        self.outputs = list()

        # The crs taken from input layers (if possible), and used when
        # loading output layers
        self.crs = None

        # If the algorithm is run as part of a model, the parent model
        # can be set in this variable, to allow for customized
        # behavior, in case some operations should be run differently
        # when running as part of a model
        self.model = None

    # methods to overwrite when creating a custom geoalgorithm

    def processAlgorithm(self, parameters, context, feedback):
        """Here goes the algorithm itself.

        There is no return value from this method.
        A QgsProcessingException should be raised in case
        something goes wrong.
        :param parameters:
        :param context:
        """
        pass

    def getCustomModelerParametersDialog(self, modelAlg, algName=None):
        """If the algorithm has a custom parameters dialog when called
        from the modeler, it should be returned here, ready to be
        executed.
        """
        return None

    def processBeforeAddingToModeler(self, alg, model):
        """Add here any task that has to be performed before adding an algorithm
        to a model, such as changing the value of a parameter depending on value
        of another one"""
        pass

    # =========================================================

    def execute(self, parameters, context=None, feedback=None, model=None):
        """The method to use to call a processing algorithm.

        Although the body of the algorithm is in processAlgorithm(),
        it should be called using this method, since it performs
        some additional operations.

        Raises a QgsProcessingException in case anything goes
        wrong.
        :param parameters:
        """

        if feedback is None:
            feedback = QgsProcessingFeedback()
        if context is None:
            context = dataobjects.createContext(feedback)

        self.model = model
        try:
            self.setOutputCRS()
            self.resolveOutputs()
            self.runPreExecutionScript(feedback)
            self.processAlgorithm(parameters, context, feedback)
            feedback.setProgress(100)
            self.convertUnsupportedFormats(context, feedback)
            self.runPostExecutionScript(feedback)
        except QgsProcessingException as gaee:
            lines = [self.tr('Error while executing algorithm')]
            lines.append(traceback.format_exc())
            QgsMessageLog.logMessage(gaee.msg, self.tr('Processing'), QgsMessageLog.CRITICAL)
            raise QgsProcessingException(gaee.msg, lines, gaee)
        except Exception as e:
            # If something goes wrong and is not caught in the
            # algorithm, we catch it here and wrap it
            lines = [self.tr('Uncaught error while executing algorithm')]
            lines.append(traceback.format_exc())
            QgsMessageLog.logMessage('\n'.join(lines), self.tr('Processing'), QgsMessageLog.CRITICAL)
            raise QgsProcessingException(str(e) + self.tr('\nSee log for more details'), lines, e)

    def runPostExecutionScript(self, feedback):
        scriptFile = ProcessingConfig.getSetting(
            ProcessingConfig.POST_EXECUTION_SCRIPT)
        self.runHookScript(scriptFile, feedback)

    def runPreExecutionScript(self, feedback):
        scriptFile = ProcessingConfig.getSetting(
            ProcessingConfig.PRE_EXECUTION_SCRIPT)
        self.runHookScript(scriptFile, feedback)

    def runHookScript(self, filename, feedback):
        if filename is None or not os.path.exists(filename):
            return
        try:
            script = 'import processing\n'
            ns = {}
            ns['feedback'] = feedback
            ns['alg'] = self
            with open(filename) as f:
                lines = f.readlines()
                for line in lines:
                    script += line
            exec(script, ns)
        except Exception as e:
            QgsMessageLog.logMessage("Error in hook script: " + str(e), self.tr('Processing'), QgsMessageLog.WARNING)
            # A wrong script should not cause problems, so we swallow
            # all exceptions
            pass

    def convertUnsupportedFormats(self, context, feedback):
        i = 0
        feedback.setProgressText(self.tr('Converting outputs'))
        for out in self.outputs:
            if isinstance(out, OutputVector):
                if out.compatible is not None:
                    layer = QgsProcessingUtils.mapLayerFromString(out.compatible, context)
                    if layer is None:
                        # For the case of memory layer, if the
                        # getCompatible method has been called
                        continue
                    writer = out.getVectorWriter(layer.fields(), layer.wkbType(), layer.crs(), context)
                    features = QgsProcessingUtils.getFeatures(layer, context)
                    for feature in features:
                        writer.addFeature(feature, QgsFeatureSink.FastInsert)
            elif isinstance(out, OutputRaster):
                if out.compatible is not None:
                    layer = QgsProcessingUtils.mapLayerFromString(out.compatible, context)
                    format = self.getFormatShortNameFromFilename(out.value)
                    orgFile = out.compatible
                    destFile = out.value
                    crsid = layer.crs().authid()
                    settings = QgsSettings()
                    path = str(settings.value('/GdalTools/gdalPath', ''))
                    envval = str(os.getenv('PATH'))
                    if not path.lower() in envval.lower().split(os.pathsep):
                        envval += '%s%s' % (os.pathsep, path)
                        os.putenv('PATH', envval)
                    command = 'gdal_translate -of %s -a_srs %s %s %s' % (format, crsid, orgFile, destFile)
                    if os.name == 'nt':
                        command = command.split(" ")
                    else:
                        command = [command]
                    proc = subprocess.Popen(
                        command,
                        shell=True,
                        stdout=subprocess.PIPE,
                        stdin=subprocess.PIPE,
                        stderr=subprocess.STDOUT,
                        universal_newlines=False,
                    )
                    proc.communicate()

            elif isinstance(out, OutputTable):
                if out.compatible is not None:
                    layer = QgsProcessingUtils.mapLayerFromString(out.compatible, context)
                    writer = out.getTableWriter(layer.fields())
                    features = QgsProcessingUtils.getFeatures(layer, context)
                    for feature in features:
                        writer.addRecord(feature)
            feedback.setProgress(100 * i / float(len(self.outputs)))

    def getFormatShortNameFromFilename(self, filename):
        ext = filename[filename.rfind('.') + 1:]
        supported = GdalUtils.getSupportedRasters()
        for name in list(supported.keys()):
            exts = supported[name]
            if ext in exts:
                return name
        return 'GTiff'

    def resolveOutputs(self):
        """Sets temporary outputs (output.value = None) with a
        temporary file instead. Resolves expressions as well.
        """
        try:
            for out in self.outputs:
                out.resolveValue(self)
        except ValueError as e:
            raise QgsProcessingException(str(e))

    def setOutputCRS(self):
        context = dataobjects.createContext()
        layers = QgsProcessingUtils.compatibleLayers(QgsProject.instance())
        for param in self.parameterDefinitions():
            if isinstance(param, (ParameterRaster, ParameterVector, ParameterMultipleInput)):
                if param.value:
                    if isinstance(param, ParameterMultipleInput):
                        inputlayers = param.value.split(';')
                    else:
                        inputlayers = [param.value]
                    for inputlayer in inputlayers:
                        for layer in layers:
                            if layer.source() == inputlayer:
                                self.crs = layer.crs()
                                return
                        p = QgsProcessingUtils.mapLayerFromString(inputlayer, context)
                        if p is not None:
                            self.crs = p.crs()
                            p = None
                            return
        try:
            from qgis.utils import iface
            if iface is not None:
                self.crs = iface.mapCanvas().mapSettings().destinationCrs()
        except:
            pass

    def addOutput(self, output):
        # TODO: check that name does not exist
        if isinstance(output, Output):
            self.outputs.append(output)

    def addParameter(self, param):
        # TODO: check that name does not exist
        if isinstance(param, Parameter):
            self.parameters.append(param)

    def setOutputValue(self, outputName, value):
        for out in self.outputs:
            if out.name == outputName:
                out.setValue(value)

    def removeOutputFromName(self, name):
        for out in self.outputs:
            if out.name == name:
                self.outputs.remove(out)

    def getOutputFromName(self, name):
        for out in self.outputs:
            if out.name == name:
                return out

    def getParameterValue(self, name):
        for param in self.parameters:
            if param.name == name:
                return param.value
        return None

    def getOutputValue(self, name):
        for out in self.outputs:
            if out.name == name:
                return out.value
        return None

    def tr(self, string, context=''):
        if context == '':
            context = self.__class__.__name__
        return QCoreApplication.translate(context, string)

    def trAlgorithm(self, string, context=''):
        if context == '':
            context = self.__class__.__name__
        return string, QCoreApplication.translate(context, string)


def executeAlgorithm(alg, parameters, context=None, feedback=None, model=None):
    """The method to use to call a processing algorithm.

    Although the body of the algorithm is in processAlgorithm(),
    it should be called using this method, since it performs
    some additional operations.

    Raises a QgsProcessingException in case anything goes
    wrong.
    :param parameters:
    """

    if feedback is None:
        feedback = QgsProcessingFeedback()
    if context is None:
        context = dataobjects.createContext(feedback)

    #self.model = model

    #self.setOutputCRS()
    #self.resolveOutputs()
    #self.evaluateParameterValues()
    #self.runPreExecutionScript(feedback)
    result, ok = alg.run(parameters, context, feedback)
    #self.processAlgorithm(parameters, context, feedback)
    feedback.setProgress(100)
    return result, ok
    #self.convertUnsupportedFormats(context, feedback)
    #self.runPostExecutionScript(feedback)
